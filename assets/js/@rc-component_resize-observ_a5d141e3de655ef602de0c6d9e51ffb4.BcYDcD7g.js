import{r as e}from"./react@19.2.3.DikTGMTS.js";import{s as t,n,j as r,F as o,t as s}from"./@rc-component_util@1.7.0_re_97ed4941f5d27d044aa2ecbc4a75f304.BwjZ45jd.js";const c=e.createContext(null);const u=new Map;function i(e){e.forEach(e=>{var t;const{target:n}=e;null==(t=u.get(n))||t.forEach(e=>e(n))})}let f;function a(){return f||(f=new ResizeObserver(i)),f}function l(s,i){const{children:f,disabled:l}=s,h=e.useRef(null),d=e.useContext(c),g="function"==typeof f,v=g?f(h):f,p=e.useRef({width:-1,height:-1,offsetWidth:-1,offsetHeight:-1}),m=!g&&e.isValidElement(v)&&t(v),b=m?n(v):null,R=r(b,h),w=()=>o(h.current);e.useImperativeHandle(i,()=>w());const y=e.useRef(s);y.current=s;const C=e.useCallback(e=>{const{onResize:t,data:n}=y.current,{width:r,height:o}=e.getBoundingClientRect(),{offsetWidth:s,offsetHeight:c}=e,u=Math.floor(r),i=Math.floor(o);if(p.current.width!==u||p.current.height!==i||p.current.offsetWidth!==s||p.current.offsetHeight!==c){const f={width:u,height:i,offsetWidth:s,offsetHeight:c};p.current=f;const a=s===Math.round(r)?r:s,l=c===Math.round(o)?o:c,h={...f,offsetWidth:a,offsetHeight:l};null==d||d(h,e,n),t&&Promise.resolve().then(()=>{t(h,e)})}},[]);return e.useEffect(()=>{const e=w();var t,n;return e&&!l&&(t=e,n=C,u.has(t)||(u.set(t,new Set),a().observe(t)),u.get(t).add(n)),()=>function(e,t){u.has(e)&&(u.get(e).delete(t),u.get(e).size||(a().unobserve(e),u.delete(e)))}(e,C)},[h.current,l]),m?e.cloneElement(v,{ref:R}):v}const h=e.forwardRef(l);function d(){return d=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},d.apply(this,arguments)}function g(t,n){const{children:r}=t;return("function"==typeof r?[r]:s(r)).map((r,o)=>{const s=(null==r?void 0:r.key)||"".concat("rc-observer-key","-").concat(o);return e.createElement(h,d({},t,{key:s,ref:0===o?n:void 0}),r)})}const v=e.forwardRef(g);v.Collection=function({children:t,onBatchResize:n}){const r=e.useRef(0),o=e.useRef([]),s=e.useContext(c),u=e.useCallback((e,t,c)=>{r.current+=1;const u=r.current;o.current.push({size:e,element:t,data:c}),Promise.resolve().then(()=>{u===r.current&&(null==n||n(o.current),o.current=[])}),null==s||s(e,t,c)},[n,s]);return e.createElement(c.Provider,{value:u},t)};export{v as R};
